<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>no5urgar</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="no5urgar.github.io/"/>
  <updated>2018-07-04T14:36:12.000Z</updated>
  <id>no5urgar.github.io/</id>
  
  <author>
    <name>no5urgar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「 联想 G400 笔记本 」 Hackintosh 攻略</title>
    <link href="no5urgar.github.io/2018/06/21/lenovo-g400-hackintosh-guide/"/>
    <id>no5urgar.github.io/2018/06/21/lenovo-g400-hackintosh-guide/</id>
    <published>2018-06-21T15:21:27.000Z</published>
    <updated>2018-07-04T14:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="🛠-准备工作"><a href="#🛠-准备工作" class="headerlink" title="🛠 准备工作"></a>🛠 准备工作</h4><ul><li>笔记本： 联想 G400</li><li>U 盘：SanDisk 酷铄 CZ73</li><li>内存条：金士顿 DDR3L 1600Mhz  4G x1</li><li>无线网卡&amp;蓝牙：博通 BCM94352HMB</li></ul><h4 id="🔧-BIOS-移除白名单"><a href="#🔧-BIOS-移除白名单" class="headerlink" title="🔧 BIOS 移除白名单"></a>🔧 BIOS 移除白名单</h4><p>在拿到 <strong>博通BCM 94352HMB</strong> 和  <strong>内存条</strong> 当天，就都装了上去<br> <a id="more"></a></p><p> <img src="http://wx2.sinaimg.cn/mw690/699458aegy1fsj7cdyv76j21100o0hdu.jpg" width="500"></p><p>提示 <em>Unauthorized network card is plugged….</em>  （当场 <em>白仁面</em> 去），意识到是联想坑爹的白名单限制无线网卡的型号，于是默默的打开 <strong>google</strong> … </p><p>于是，很快搜到 <a href="http://bbs.zol.com.cn/nbbbs/d160_143691.html" target="_blank" rel="noopener">Y400/Y500 史上最详细 英特尔7260AC+4.0蓝牙 究极白名单完美蓝牙改造方案</a> 、<a href="http://bbs.pcbeta.com/viewthread-1593118-1-1.html" target="_blank" rel="noopener">LENOVO G400S 刷bios去除白名单</a> ，大概阅读了下，发现并不复杂，几个步骤即可。</p><p>鉴于这次的 G400 是我家宝宝的，笔记本交给我之前下了死命令不能弄丢里面的数据，所以在刷 Bios 的时候还是挺怕刷炸主板的，还好过程一切顺利。</p><h5 id="准备工具："><a href="#准备工具：" class="headerlink" title="准备工具："></a>准备工具：</h5><p> <img src="http://wx1.sinaimg.cn/mw690/699458aegy1fskh0pa47bj21d00ugn2w.jpg" width="550"></p><ul><li>78cn25ww ：BIOS 最新版</li><li>启动U盘制作 ： 制作 U 盘为 DOS 启动盘</li><li>insyde EzH2O中文版 ： 编辑 BIOS ，移除白名单模块</li><li>tlzh：备份、写入 BIOS</li></ul><h5 id="简单步骤："><a href="#简单步骤：" class="headerlink" title="简单步骤："></a>简单步骤：</h5><p>简单讲，需要把 BIOS 的白名单模块去除，这样开机的时候就不会检测无线网卡，可以顺利进入系统；把白名单去除需要把 BIOS 备份出来，然后用 <strong>insyde EzH2O</strong> 把模块去除，然后将修改后的 BIOS 写入，备份和写入在 DOS 环境工作。</p><p> <img src="http://wx4.sinaimg.cn/mw690/699458aegy1fskhgwvmkdj21kw16ou0x.jpg" width="500"></p><p>值得一提的是，在使用 <strong>insyde EzH2O</strong> 移除白名单模块的时候，因为上述文章机型并不是 G400 ，所以移除的时候不太确定文中的 <code>GUID &quot;11D378C2-B472-412F-AD87-1BE4CD8B33A6&quot;</code> 是不是对应 G400 的无线网卡白名单模块，但是网上搜不到 G400 的，加上都是联想的机器，想着应该都是一样的，就直接删除这个模块，这个过程忘记截图拍照… 最终成功开机，意味着白名单模块成功移除，win 系统下 wifi 📶 正常。</p><h4 id="⚙️-Mac-系统-U-盘制作、分区"><a href="#⚙️-Mac-系统-U-盘制作、分区" class="headerlink" title="⚙️ Mac 系统 U 盘制作、分区"></a>⚙️ Mac 系统 U 盘制作、分区</h4><p>下载带 <strong>Clover</strong> 的 <a href="http://bbs.pcbeta.com/viewthread-1787600-1-1.html" target="_blank" rel="noopener">macOS High Sierra 原版镜像</a>  ，该镜像自带适合各个机型的 Clover 的配置文件以及涵盖大部分网卡、显卡、万能声卡驱动</p><p>如果已经有 macOS 平台，在磁盘工具中利用恢复功能将镜像恢复到 U 盘即可，恢复成功后 u 盘会自动分成两个分区，一个存放  macOS ，另一个 EFI 分区存放 Clover 用于启动引导。</p><p> <img src="http://wx2.sinaimg.cn/mw690/699458aegy1fsuurx9ewsj21kw11n7bm.jpg" width="500"></p><p>如果你没有 macOS 平台，那么需要 <strong>Tranmacs</strong> 来将 dmg 文件写入 U 盘，同样写入完成会生成两个分区。</p><p>【这里应有图片】</p><p>EFI 分区默认隐藏，在 mac 中借用 Clover Configurator 可以打开隐藏了的 EFI 分区，在 Clover 目录中，选择适合自己电脑配置的 config 文件，只要选择正确，一般都能正常走完安装流程。</p><p> <img src="http://wx3.sinaimg.cn/mw690/699458aegy1fsuus3jntlj21kw0xuaqr.jpg" width="500"></p><h4 id="🗡-安装-macOS"><a href="#🗡-安装-macOS" class="headerlink" title="🗡 安装 macOS"></a>🗡 安装 macOS</h4><p>安装之前先确保 EFI 分区 &gt;= 200M ，且已为 macOS 准备好一个分区（此过程建议在 PE 中进行），并在 Bios 中关闭 Secure Boot 。</p><p>用写好镜像和 Clover 的 U 盘启动电脑，选择 macOS install ，耐心等待，待成功进入安装界面后将准备要装 macOS 的分区抹掉，选择 <strong>Mac OS 扩展</strong> 格式，抹掉成功后选择安装在该分区即可，安装过程没有什么需要注意的，无脑下一步就可以了，重新继续安装，配置账号信息等，直到安装完毕进入桌面。</p><p>过程中，除了第一次 Clover 引导选择页面需要选择 masOS install（即写入到 u 盘的 macOS 安装镜像），第二次开始到以后都选择划分给 macOS 的分区进入系统。 </p><h4 id="⚽️-完善驱动、DSDT、SSDT"><a href="#⚽️-完善驱动、DSDT、SSDT" class="headerlink" title="⚽️ 完善驱动、DSDT、SSDT"></a>⚽️ 完善驱动、DSDT、SSDT</h4><p>此时仍然以准备的 U 盘来启动系统，一般 Clover 的配置文件选择正确，加上不少自带的驱动，所以第一次进入系统显卡、声卡（万能声卡）、网卡（有线无线）、蓝牙都能成功驱动，剩余 <em>电池电量、屏幕亮度控制、变频</em> 等利用 DSDT、SSDT 解决。</p><blockquote><p> <a href="https://github.com/RehabMan/OS-X-MaciASL-patchmatic" target="_blank" rel="noopener">MaciASL</a> 是一个苹果原生的，可以用来 修改、编译 DSDT、SSDT等ACPI文件的软件<br> <a href="https://github.com/RehabMan/Laptop-DSDT-Patch" target="_blank" rel="noopener">Rehabman的综合补丁源</a> Rehabman大神的 DSDT 补丁源，如果你的机型在补丁列表里面，那么恭喜，直接打上该补丁即可</p></blockquote><p><a href="http://bbs.pcbeta.com/viewthread-1571455-1-1.html" target="_blank" rel="noopener">[授权翻译] 使用补丁修改DSDT/SSDT [DSDT/SSDT综合教程]</a> 配合 <a href="https://github.com/RehabMan/Laptop-DSDT-Patch" target="_blank" rel="noopener">补丁源</a> 食用，打上 电池电量、屏幕亮度控制 等几个必要补丁，复制到 clover 中，重启即可生效。</p><h4 id="👾-收尾"><a href="#👾-收尾" class="headerlink" title="👾 收尾"></a>👾 收尾</h4><p>最后把完整的 Clover 复制到硬盘上的 EFI 分区，至此圆满安装成功，可脱离 U 盘使用。</p><p>在简单甩几个链接之后，攻略也就这样结束了，仅此作为记录 <strong>黑苹果</strong> 的折腾思路参考，安装过程中或多或少（根据到目前为止安装超过5台笔记本的、大学3年黑苹果使用经验）会有各种问题，推荐在<em><a href="bbs.pcbeta.com">远景</a></em>中搜一下一般都能解决。祝好运～ </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;🛠-准备工作&quot;&gt;&lt;a href=&quot;#🛠-准备工作&quot; class=&quot;headerlink&quot; title=&quot;🛠 准备工作&quot;&gt;&lt;/a&gt;🛠 准备工作&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;笔记本： 联想 G400&lt;/li&gt;
&lt;li&gt;U 盘：SanDisk 酷铄 CZ73&lt;/li&gt;
&lt;li&gt;内存条：金士顿 DDR3L 1600Mhz  4G x1&lt;/li&gt;
&lt;li&gt;无线网卡&amp;amp;蓝牙：博通 BCM94352HMB&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;🔧-BIOS-移除白名单&quot;&gt;&lt;a href=&quot;#🔧-BIOS-移除白名单&quot; class=&quot;headerlink&quot; title=&quot;🔧 BIOS 移除白名单&quot;&gt;&lt;/a&gt;🔧 BIOS 移除白名单&lt;/h4&gt;&lt;p&gt;在拿到 &lt;strong&gt;博通BCM 94352HMB&lt;/strong&gt; 和  &lt;strong&gt;内存条&lt;/strong&gt; 当天，就都装了上去&lt;br&gt;
    
    </summary>
    
    
      <category term="hackintosh,g400" scheme="no5urgar.github.io/tags/hackintosh-g400/"/>
    
  </entry>
  
  <entry>
    <title>【《Objective-C 高级编程 iOS 与 OS X 多线程与内存管理 》 阅读系列 】之 自动引用计数篇（一）</title>
    <link href="no5urgar.github.io/2018/06/09/objc-summary-arc-first/"/>
    <id>no5urgar.github.io/2018/06/09/objc-summary-arc-first/</id>
    <published>2018-06-09T13:11:43.000Z</published>
    <updated>2018-06-09T13:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx2.sinaimg.cn/mw690/699458aegy1fs591c4724j21590p0u0x.jpg" alt=""></p><blockquote><h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>本系列，作为 《Objective-C 高级编程 iOS 与 OS X 多线程与内存管理 》一书的阅读总结，内容以原书内容提炼 + 内容扩展+个人理解，但大部分还是以提炼书中内容为主，以保证内容正确性。  </p><p>相信大部分 iOS 开发者都对 <strong>自动引用计数</strong> 不陌生，<strong>自动引用计数（ARC，Automatic Reference Counting）</strong>是指内存管理中对引用采取自动计数的技术，官方文档说的是：“<strong>在 LVVM 编译器中设置 ARC 为有效状态，就无需再次键入 retain 或者是 release 代码</strong>”。</p><p>在介绍 ARC  之前，我们先了解什么是引用计数，也就是 Objective-C 中的内存管理。</p></blockquote><a id="more"></a><h4 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h4><blockquote><p>我们都知道，在 MRC 中，当对象的被创建并被持有时，对象的引用计数为 1 ，执行 <code>[id retain]</code> 对象的引用计数递增，执行 <code>[id release]</code> 对象的引用计数递减，当对象的引用计数递减到 0 时，对象被销毁。</p></blockquote><p>以上为 iOS 开发者所熟知的 Objective-C 内存管理方式，下面简单介绍 Objective-C 如何通过引用计数来控制对象的生命周期。</p><p>对于 <code>64</code> 位环境（ iPhone5s 之后的机型）来说，对象中指向一个 <code>isa_t</code> 结构体的 isa 指针包含类的各种信息，“一些”对象的<code>isa_t</code> 会拿出一部分空间存储引用计数，会有 19 位来存储引用计数。<br>对于较老机型 <code>19bit</code> 环境保存引用计数不一定够，那么这个时候引用计数会由专门的 SideTable 类来存储。</p><p><strong><code>isa_t</code> 结构体</strong> </p><pre><code>struct objc_object {    isa_t isa;};//union isa_t  {isa_t() { }isa_t(uintptr_t value) : bits(value) { }Class cls;uintptr_t bits;   struct {        uintptr_t indexed           : 1;        uintptr_t has_assoc         : 1;        uintptr_t has_cxx_dtor      : 1;        uintptr_t shiftcls          : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000        uintptr_t magic             : 9;        uintptr_t weakly_referenced : 1;        uintptr_t deallocating      : 1;        uintptr_t has_sidetable_rc  : 1;        uintptr_t extra_rc          : 19;        define RC_ONE   (1ULL&lt;&lt;45)        define RC_HALF  (1ULL&lt;&lt;18)    };</code></pre><p>可以看出， isa 指向的结构体包含对象的各种信息，其中几个与引用计数有关的变量：</p><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">indexed</td><td style="text-align:center">0 表示普通的 isa 指针，1 表示使用优化，存储引用计数</td></tr><tr><td style="text-align:center">has_sidetable_rc</td><td style="text-align:center">表示该对象的引用计数值是否过大无法存储在 isa 指针</td></tr><tr><td style="text-align:center">extra_rc</td><td style="text-align:center">存储引用计数值减一后的结果</td></tr></tbody></table><p><strong>SideTable 类 用来管理引用计数表和 weak 表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spinlock_t slock;//保证原子操作的自选锁</span><br><span class="line">RefcountMap refcnts;//保存引用计数的散列表</span><br><span class="line">weak_table_t weak_table; //保存 weak 引用的全局散列表</span><br></pre></td></tr></table></figure><h4 id="2-内存的思考方式"><a href="#2-内存的思考方式" class="headerlink" title="2. 内存的思考方式"></a>2. 内存的思考方式</h4><p>书中介绍，对于计数式内存管理的客观、正确的思考方式是：</p><ol><li>自己生成的对象，自己所持有</li><li>非自己生成的对象，自己也能持有</li><li>不再需要自己持有的对象时释放</li><li>非自己持有的对象无法释放</li></ol><p>对象操作与 Objective-C 方法</p><table><thead><tr><th style="text-align:center">对象操作</th><th style="text-align:center">Objective-C 方法</th></tr></thead><tbody><tr><td style="text-align:center">生成并持有对象</td><td style="text-align:center">alloc/new/copy/mutableCopy 等方法</td></tr><tr><td style="text-align:center">持有对象</td><td style="text-align:center">retain 方法</td></tr><tr><td style="text-align:center">释放对象</td><td style="text-align:center">release 方法</td></tr><tr><td style="text-align:center">废弃对象</td><td style="text-align:center">dealloc 方法</td></tr></tbody></table><p>思考方式除第 2 点外，其他都好理解，着重看下第 2 点，对于使用 <code>alloc</code> <code>new</code> <code>copy</code> <code>mutableCopy</code> 生成的对象，我们认为是自己生成的对象，且自己持有，那么什么是“非自己生成的对象”？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)allocObject</span><br><span class="line">&#123;</span><br><span class="line">/** 自己生成并持有对象 */</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** 取得非自己生成并持有的对象 */</span><br><span class="line">id obj1 = [obj0 allObject];</span><br></pre></td></tr></table></figure><p>以上是 “非自己生成的对象并持有”，那么“非自己生成的对象自己又不持有呢”？  </p><p>MRC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)object</span><br><span class="line">&#123;</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">/** 取得对象存在，但自己不持有 */</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = [obj0 object];</span><br><span class="line">/** 取得非自己生成且不持有的对象 */</span><br><span class="line">[obj1 retain];</span><br><span class="line">/** 自己持有对象 */</span><br></pre></td></tr></table></figure><p>使用 <code>autorelease</code> 方法，使得取得的对象存在，但自己不持有对象，因为该对象将在超出指定的生存范围时能够自动并正确地释放（调用 <code>release</code> 方法），<code>autorelease</code> 方法会像 c 语言的自动变量那样来对待对象实例，当超出其作用域（相当于变量作用域）时，对象实例的 <code>release</code>实例方法被调用，且<strong>可以设定对象实例的作用域</strong></p><p><code>autorelease</code> 的具体使用方法：</p><ol><li>生成并持有 NSAutoreleasePool 对象</li><li>调用已分配对象的 <code>autorelease</code> 实例方法</li><li>废弃 NSAutoreleasePool 对象</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/mw690/699458aegy1fs591c4724j21590p0u0x.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h4&gt;&lt;p&gt;本系列，作为 《Objective-C 高级编程 iOS 与 OS X 多线程与内存管理 》一书的阅读总结，内容以原书内容提炼 + 内容扩展+个人理解，但大部分还是以提炼书中内容为主，以保证内容正确性。  &lt;/p&gt;
&lt;p&gt;相信大部分 iOS 开发者都对 &lt;strong&gt;自动引用计数&lt;/strong&gt; 不陌生，&lt;strong&gt;自动引用计数（ARC，Automatic Reference Counting）&lt;/strong&gt;是指内存管理中对引用采取自动计数的技术，官方文档说的是：“&lt;strong&gt;在 LVVM 编译器中设置 ARC 为有效状态，就无需再次键入 retain 或者是 release 代码&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;在介绍 ARC  之前，我们先了解什么是引用计数，也就是 Objective-C 中的内存管理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Objective-C,ARC,Autorelease" scheme="no5urgar.github.io/tags/Objective-C-ARC-Autorelease/"/>
    
  </entry>
  
  <entry>
    <title>【日常生产 · 阿威十八式】 の  武器篇 - 冈本零点零一</title>
    <link href="no5urgar.github.io/2018/05/20/product%E2%80%94weapon-okamoto/"/>
    <id>no5urgar.github.io/2018/05/20/product—weapon-okamoto/</id>
    <published>2018-05-20T03:34:26.000Z</published>
    <updated>2018-05-20T16:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>一人之下 2 就这样完结了，第 3 季据说要 8-9 月份，这可如何是好，昨晚一口气把“ 端脑 ”刷完了，国产动漫现在是越来越好了，顺便扯扯冰火今年至今还没有要开播的消息啊，难道要等到 19 年吗。</p><p>这个系列暂时就叫 《日常生产 · 啊威十八式》 哈哈哈，啊威十八式，全活不打折；第一篇的话，就从宝宝的锋利无比的菜刀冈本零点零一开始，这篇主要是一些工具的分享，包括 iOS 、macOS 上。</p><a id="more"></a><h4 id="生产工具"><a href="#生产工具" class="headerlink" title="生产工具"></a>生产工具</h4><ul><li>手机：iPhone6s </li><li>电脑：Macbook Air 2014 </li><li>显示器： Dell P2418D </li><li>键盘： IKBC C87 红轴 </li><li>鼠标： Magic Mouse 2 </li></ul><h4 id="「-iOS-」"><a href="#「-iOS-」" class="headerlink" title="「 iOS 」"></a>「 iOS 」</h4><ul><li><p><strong>微博</strong>严重依赖党，属于半天不刷微博会死星人那种，官方客户端是不可能用会用的，这辈子都不可能用官方客户端，这里介绍几个手机常驻的微博客户端，各有各的优点吧。</p><ol><li><p><strong>vvebo</strong> 这是迄今为止 iOS 上用过的最流畅的 APP 之一，滑动的时候简直就是享受，不像别的有些虽然也流畅但感觉会有点飘，但是这个好久没更新了，功能也是有限的，但对于只刷 timeline 加收藏党的我已经满足了绝大部分需求，作者有在其微博上说今年会有更新，虽然今年都过了一半了… </p></li><li><p><strong>cosmos</strong>   <a href="http://kittenyang.com/" target="_blank" rel="noopener">KITTEN-YANG</a> 的作品，功能最齐全的第三方微博客户端，最赞的是自带视频下载功能，动画效果也是最多的。</p></li><li><p><strong>墨客</strong> 最近一段时间用的比较多的反而是墨客，属于比较实用的吧，功能齐全，界面简洁，没有 cosmos 那么多的动画，反而能够专心的刷微博 ~.~ </p></li><li><p>此外还有 <strong>奇点</strong> 这款客户端，也是可以尝试的一款客户端，之前是觉得名字不好听以及 logo 不好看（作者别打我，个人主观看法）就没有在我手机上留下来，不过奇点有自己特色的功能，没怎么用就不过多评价了。</p></li></ol></li><li><p><strong>正确的上网姿势</strong>，推荐 <a href="https://efan.io/aff.php?aff=146" target="_blank" rel="noopener">efan.io</a> ，用了一年半了，除了去年开会期间不稳定外，平时都挺稳定的，香港节点 pin 才 20 ms ，另外如果搬瓦工最近 19.9 美元套餐又有货了，对流量需求比较多的可以看看搬瓦工，具体看 <a href="http://www.right.com.cn/forum/thread-267152-1-1.html" target="_blank" rel="noopener">这里</a> ，配合 <code>Shadowrocket</code> 食用更美味，目前国区已下架，需要到美区下载，另外配置文件可以参考这个仓库 <a href="https://github.com/Hackl0us/SS-Rule-Snippet" target="_blank" rel="noopener">SS-Rule-Snippet</a> 。</p></li><li><p><strong>1Password</strong> 一直用的密码管理工具 ，免费版功能已经很强大了，强烈推荐。</p></li><li><p><strong>追书神器</strong> 大学一直在用的 APP，如果不想付费的话，万能的淘宝有旧版本卖，有换源免费看。</p></li><li><p><strong>熊猫吃短信</strong> 基于 core ML 的智能垃圾、广告信息拦截，唯一的缺点是拦截后短信图标还有红点提示，需要手动点开短信才能关掉红点。</p></li><li><p><strong>Pocket</strong> 稍后阅读工具，chrome 和 safair 都有插件可以直接添加文章到 Pocket 上，有空或者需要的时候再看。</p></li></ul><p>手机其实除了当测试机外对于生产没什么关系，不过是推荐几个日常用的比较多的 APP 。</p><h4 id="「-macOS-」"><a href="#「-macOS-」" class="headerlink" title="「 macOS 」"></a>「 macOS 」</h4><ul><li><p>air 重装了一次系统后用了 bs 的 <strong><a href="(https://github.com/bestswifter/macbootstrap">macbootstrap</a>)</strong> 脚本一次性配置好所有日常所需的生产环境，给 bs 点个赞，像 iTerm 、 CodeRunner 这些都会自动安装好，真是大大提高效率。</p></li><li><p><strong>IINA</strong>  免费开源的万能视频播放器，macOS 上最好用的视频播放器没有之一，支持几乎所有主流视频格式，好看的 UI 、LOGO ，还是 Swift 开发的噢。</p></li><li><p><strong>macdown</strong>  markdown 编辑器，也是这几天刚换成这款，感觉比 Typora 好用，Typora 有时候格式无法复制出来，同事小宝推荐这款，发现确实不错，换了思源字体效果棒棒哒，markdown 效果也支持自定义，不过自带的蛮好看的就没有去修改了。</p></li><li><p><a href="https://www.zhihu.com/question/35300978" target="_blank" rel="noopener">2K 屏开 1080P 的 HIDPI </a>，Air 的屏幕看着难受，今年五一假期入了 Dell 的 P2418D ，一款 2K 显示器，本来想直接上 4K ，但查了下 Air 跑不动 4K ，所以只能降低要求买个 2K ，实际用起来也只是勉强能用而已，虽然效果（开 1080P HIDPI）已经到满意程度，但是页面拖动卡顿还是比较明显的，看视频是没问题的。</p></li><li><p><strong>百度云</strong>  macOS 客户端不限速下载 <a href="https://github.com/CodeTips/BaiduNetdiskPlugin-macOS" target="_blank" rel="noopener">补丁</a> </p></li><li><p><strong>ShadowsocksX-NG</strong> 使用 PAC 模式即可自动识别是否使用代理，个别判断错误的自行添加规则即可。</p></li><li><p><strong>The Unarchiver</strong> macOS 的 WinRAR ，自从用 mac 就一直用这款解压软件了。</p></li><li><p><strong>Afred 3</strong> 神器 Afred ，可谓相见恨晚，强大的检索和自定义工作流功能，这里不过多描述，下次开一篇文章单独介绍。</p></li></ul><h4 id="「-硬件相关-」"><a href="#「-硬件相关-」" class="headerlink" title="「 硬件相关 」"></a>「 硬件相关 」</h4><ul><li>这一块后面黑苹果更新， air 感觉有点力不从心了，过些时候组个黑苹果吧。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一人之下 2 就这样完结了，第 3 季据说要 8-9 月份，这可如何是好，昨晚一口气把“ 端脑 ”刷完了，国产动漫现在是越来越好了，顺便扯扯冰火今年至今还没有要开播的消息啊，难道要等到 19 年吗。&lt;/p&gt;
&lt;p&gt;这个系列暂时就叫 《日常生产 · 啊威十八式》 哈哈哈，啊威十八式，全活不打折；第一篇的话，就从宝宝的锋利无比的菜刀冈本零点零一开始，这篇主要是一些工具的分享，包括 iOS 、macOS 上。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS Develop Tips</title>
    <link href="no5urgar.github.io/2018/05/16/iOS-Develop-Tips/"/>
    <id>no5urgar.github.io/2018/05/16/iOS-Develop-Tips/</id>
    <published>2018-05-16T14:57:20.000Z</published>
    <updated>2018-06-09T13:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://assets.chaojita.cn/68759513_p0_master1200.png" alt="こよりん"></p><center>配图来自 <a href="https://www.pixiv.net/member_illust.php?mode=manga&amp;illust_id=68759513" target="_blank" rel="noopener">こよりん</a> ，已取得作者授权 ~</center><p>记录工作生产过程中一些 iOS 相关基础知识点，本文将不断更新</p><a id="more"></a><ul><li>私有 <strong>api</strong> 混淆</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/** Objective-C 版 */</span><br><span class="line">//base64编码</span><br><span class="line">- (NSString *)encodeString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSString *encodedStr = [data base64EncodedStringWithOptions:0];</span><br><span class="line">    return encodedStr;</span><br><span class="line">&#125;</span><br><span class="line">//base64解码</span><br><span class="line">- (NSString *)decodeString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    NSData *data = [[NSData alloc] initWithBase64EncodedString:string options:0];</span><br><span class="line">    NSString *decodedStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">    return decodedStr;</span><br><span class="line">&#125;</span><br><span class="line">//调用私有api</span><br><span class="line">- (void)testPrivateApi</span><br><span class="line">&#123;</span><br><span class="line">    NSString *path = [self decodeString:@&quot;L1N5c3RlbS9MaWJyYXJ5L1ByaXZhdGVGcmFtZXdvcmtzL01vYmlsZUNvbnRhaW5lck1hbmFnZXIuZnJhbWV3b3Jr&quot;];</span><br><span class="line">    NSBundle *container = [NSBundle bundleWithPath:path];</span><br><span class="line">    if ([container load]) &#123;</span><br><span class="line">        Class appContainer = NSClassFromString([self decodeString:@&quot;TUNNQXBwQ29udGFpbmVy&quot;]);</span><br><span class="line">        NSString *sel = [self decodeString:@&quot;Y29udGFpbmVyV2l0aElkZW50aWZpZXI6ZXJyb3I6&quot;];</span><br><span class="line">        id test = [appContainer performSelector:NSSelectorFromString(sel) withObject:@&quot;com.tencent.xin&quot; withObject:nil];</span><br><span class="line">        if (test) &#123;</span><br><span class="line">            NSLog(@&quot;存在该应用&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Swift 版 */</span></span><br><span class="line"><span class="comment">//base64编码</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data: <span class="type">Data</span>? = string.data(using: .utf8)</span><br><span class="line">        <span class="keyword">let</span> encodedStr = data?.base64EncodedString(options: [])</span><br><span class="line">        <span class="keyword">return</span> encodedStr ?? <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//base64解码</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(<span class="number">_</span> string: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="type">Data</span>(base64Encoded: string, options: [])</span><br><span class="line">        <span class="keyword">let</span> decodedStr = <span class="type">String</span>(data: data ?? <span class="type">Data</span>(), encoding: .utf8)</span><br><span class="line">        <span class="keyword">return</span> decodedStr ?? <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用私有api</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPrivateApi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> path = decodeString(<span class="string">"L1N5c3RlbS9MaWJyYXJ5L1ByaXZhdGVGcmFtZXdvcmtzL01vYmlsZUNvbnRhaW5lck1hbmFnZXIuZnJhbWV3b3Jr"</span>)</span><br><span class="line">    <span class="keyword">let</span> container = <span class="type">Bundle</span>(path: path)</span><br><span class="line">    <span class="keyword">if</span> container?.load() ?? <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> appContainer: <span class="type">AnyClass</span> = <span class="type">NSClassFromString</span>(decodeString(<span class="string">"TUNNQXBwQ29udGFpbmVy"</span>))</span><br><span class="line">        <span class="keyword">let</span> sel = decodeString(<span class="string">"Y29udGFpbmVyV2l0aElkZW50aWZpZXI6ZXJyb3I6"</span>)</span><br><span class="line">        <span class="keyword">let</span> test = appContainer.perform(<span class="type">NSSelectorFromString</span>(sel), with: <span class="string">"com.tencent.xin"</span>, with: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> test &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"存在该应用"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>跳转系统相册 私有 <strong>Url Schemes </strong> <code>photos-redirect://**</code></p><p>需要进行混淆，不然在上传到 itunes 被拒</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> urlStr = <span class="string">"photos-redirect://"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string:urlStr) &#123;</span><br><span class="line">               <span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123;</span><br><span class="line">                    <span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(url, options: <span class="type">Dictionary</span>(), completionHandler: <span class="literal">nil</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">                    <span class="type">UIApplication</span>.shared.openURL(url)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 变为未保存状态</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>presentViewController延迟跳转, 或者点击 2 次才跳转</li></ul><p>解决方案<strong>:</strong></p><p>把presentViewController放在主线程中执行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [self presentViewController: viewController animated:YES completion: nil];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>Swift </strong>中的 <strong>deinit</strong> 方法</li></ul><p>deinit属于析构函数</p><p>析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数和OC中 dealloc一样的,通常在deinit和dealloc中需要执行的操作有:</p><ol><li>对象销毁</li><li>KVO移除</li><li>移除通知</li><li>NSTimer销毁</li></ol><ul><li><strong>cocoapods</strong> 无法安装最新版本的库</li></ul><p>执行 <code>pod repo update</code> 更新一下就可以了</p><ul><li><strong>swift4</strong> 写入 <strong>string</strong> 数据到 <strong>txt</strong> 文件</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到目录</span></span><br><span class="line"><span class="keyword">let</span> filePath:<span class="type">String</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/fringeItems.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入  response为string类型数据</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> response.write(toFile: filePath, atomically: <span class="literal">true</span>, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> data: <span class="type">String</span> = <span class="keyword">try</span> <span class="type">String</span>.<span class="keyword">init</span>(contentsOfFile: filePath)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该文件是否存在</span></span><br><span class="line"><span class="keyword">var</span> isExist:<span class="type">Bool</span> = <span class="type">FileManager</span>.<span class="keyword">default</span>.fileExists(atPath: filePath)</span><br></pre></td></tr></table></figure><ul><li><strong>swift4</strong> 获取模拟器沙盒目录</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> paths = <span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">FileManager</span>.<span class="type">SearchPathDirectory</span>.documentDirectory, <span class="type">FileManager</span>.<span class="type">SearchPathDomainMask</span>.userDomainMask, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ul><li>重写 hitTest 方法，使点击透过 view</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">hitTest</span><span class="params">(<span class="number">_</span> point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line">    <span class="keyword">let</span> hitView = <span class="keyword">super</span>.hitTest(point, with: event)</span><br><span class="line">    <span class="keyword">if</span> hitView == <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果因为 cell 复用导致内容重复 </p><p>一般不推荐使用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;GUIDEPAGEVIEWCELLID&quot;, for: indexPath) as! GuidePageViewCell</span><br><span class="line">cell.contentView.subviews.forEach &#123; (view) in</span><br><span class="line">    view.removeFromSuperview()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过脚本群发 iMessage 信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set csvData to read "/Users/ennisk/Desktop/phone.csv"</span><br><span class="line">set csvEntries to paragraphs of csvData</span><br><span class="line"></span><br><span class="line">tell application "System Events"</span><br><span class="line">tell application "Messages" to activate</span><br><span class="line">end tell</span><br><span class="line"></span><br><span class="line">tell application "Messages"</span><br><span class="line">repeat with i from 1 to count csvEntries</span><br><span class="line">set phone to (csvEntries's item i)'s text</span><br><span class="line">set myid to get id of first service</span><br><span class="line">set theBuddy to buddy phone of service id myid</span><br><span class="line">send "test message" to theBuddy</span><br><span class="line">end repeat</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><p>其中 phone.csv 的手机号码格式为  86158<em>**</em>3823</p><p>且只有已发过一次iMessage消息的前提下才能发得出去消息</p><ul><li>输出所有字体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)allFont &#123; </span><br><span class="line">for (NSString *allFont in [UIFont familyNames]) &#123; </span><br><span class="line">NSLog(@&quot;%@&quot;, allFont); </span><br><span class="line">for (NSString *fontName in [UIFont fontNamesForFamilyName:allFont]) &#123;</span><br><span class="line">        NSLog(@&quot; %@&quot;, fontName); </span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://assets.chaojita.cn/68759513_p0_master1200.png&quot; alt=&quot;こよりん&quot;&gt;&lt;/p&gt;
&lt;center&gt;配图来自 &lt;a href=&quot;https://www.pixiv.net/member_illust.php?mode=manga&amp;amp;illust_id=68759513&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;こよりん&lt;/a&gt; ，已取得作者授权 ~&lt;/center&gt;

&lt;p&gt;记录工作生产过程中一些 iOS 相关基础知识点，本文将不断更新&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="no5urgar.github.io/categories/iOS/"/>
    
    
      <category term="iOS,tips" scheme="no5urgar.github.io/tags/iOS-tips/"/>
    
  </entry>
  
</feed>
